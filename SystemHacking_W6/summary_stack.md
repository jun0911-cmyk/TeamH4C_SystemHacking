# Stack : 설명문 1장 요약 (TeamH4C 과제)

## Stack 이란?

우리는 코딩을 하다보면 stack이라는 것에 대해 많이 듣게 됩니다.
그만큼 Stack은 코딩을 할때 많이 사용되고 프로그램의 동작상에도 매우 중요한 역할을 수행합니다.
Stack은 컴퓨터의 자료구조인데, 크게 push, pop 이라는 함수를 통해서 구현합니다.
예시로, 자동차 컨테이너에서 차량을 뽑아낼 때, 자동차는 한대씩 안으로 들어오고 나갈때는 뒤에서부터 한대씩 빠져나갑니다.
스택도 이와 같은 원리로 데이터가 차곡차곡 앞에서 부터 쌓이고 맨 뒤에서 부터 데이터가 빠져나옵니다.
사람들은 이러한 원리를 선입후출(Last in First out)이라고 합니다.
아래는 스택의 예시입니다.

```
+-------+               +-------+               +-------+             +-------+               +-------+
|       |               |       |               |       |             |       |               |       |
|       |               |       |               |       |             |       |               |       |
|       | -- push(0) -> |       | -- push(1) -> |       | -- pop() -> |       | -- push(2) -> |       |
|       |               |       |               |   1   |             |       |               |   2   |
|       |               |   0   |               |   0   |             |   0   |               |   0   |
+-------+               +-------+               +-------+             +-------+               +-------+
```

이처럼 push 함수를 사용하면 데이터를 쌓아나가고, pop 함수를 사용하면 데이터를 빼옵니다.

## Stack이 사용되는 예시 (함수 호출 스택 : Call Stack)

스택이 사용되는 예시는 아주 많지만 그중 하나를 예시로 들어보자면 함수 호출 스택이 있습니다.
함수에서도 스택이 아주 많이 사용됩니다, 그중 함수를 호출하고 나서 다시 메인 함수로 돌아오는 과정을 처리할 때 호출 스택이 사용됩니다.
여기서 함수 호출 스택(콜 스택)은 프로그램이 함수 호출(Function call)을 추적할 때 사용하는 것입니다.
콜 스택은 각 function call 당 하나씩의 스택들로 이루어져 있습니다.
C언어에서 지역변수와 전역변수의 차이점도 이런 함수의 호출 스택으로 인해서 벌어지는 것이라고 볼 수 있습니다.
전역변수와 지역변수의 차이점을 한번 정리해보면 아래와 같습니다.

1. 지역변수 : 함수 내에서만 사용되는 변수 (함수 내에서 선언되는 변수 함수가 끝날때 사라집니다.)
2. 전역변수 : 함수 밖에서 사용되는 변수 (함수 밖에서 선언되는 변수 프로그램이 종료될때 사라집니다.)

전역변수와 지역변수 그리고 함수 호출스택에 대한 간단한 C언어 코드를 예시로 들자면 아래와 같습니다

```c
#include <stdio.h>

void local_func1_2() {
    printf("local_func1_2\n");
}

void local_func1_1() {
    printf("local_func1_1\n");
}

void local_func() {
    int local_var = 20;
    local_func1_1();
    local_func1_2();
}

int main() {
    int global_var = 10;
    printf("global_var : %d\n", global_var);
    local_func();
    printf("local_var : %d\n", local_var); // ERRROR
}
```

이와 같은 코드는 오류가 납니다, 지역 변수로 선언된 변수를 다른 스코프 내에서 참조하려고 할때 발생하는 오류입니다.
오류가 발생하는 이유를 함수 호출 스택으로 표현해보면 간단합니다.

```
+-------+    +------------+    +---------------------+    +------------+    +------+
|       |    |            |    |    local_func_1_2   |    |            |    |      |
|       |    |            |    |    local_func_1_1   |    |            |    |      |
|       | -> | local_func | -> |    local_func       | -> | local_func | -> |      |
| main  |    |    main    |    |        main         |    |    main    |    | main |
+-------+    +------------+    +---------------------+    +------------+    +------+
```

함수를 호출하면 함수 호출스택이라는 곳에 함수가 쌓이게 되고 함수가 종료될떄 함수 호출스택에서도 빠져나오게 됩니다.
처음으로 main 함수가 local_func 함수를 호출함에 따라 콜스택에 쌓이게 되고 local_func 함수는 local_func_1_1과 local_func_1_2 함수를 호출함에 따라 또 콜스택에 쌓입니다.
그 다음 local_func_1_1과 local_func_1_2 함수가 종료되어 콜스택에서 빠져나가고 마지막으로 local_func 함수도 빠져나가기 때문에 main 함수만 콜스택 상에 존재하게 됩니다.
즉, global_var 변수는 main 함수가 아직 스택 내에 존재하기 때문에 참조가 가능하지만 local_var 변수는 local_func 함수가 종료되자마자 사라졌기 때문에 main 함수에서 한번 더 참조하려고 할 때 오류가 발생하는 것입니다, 이와 같은 상황을 스택 명령어로 표현해보면 아래와 같습니다.

1. push(main)
2. push(local_func)
3. push(local_func_1_1)
4. push(local_func_1_2)
5. pop(local_func_1_1)
6. pop(local_func_1_2)
7. pop(local_func)

이것이 스택의 가장 중요한 원칙입니다.

## 느낀점

Stack을 제공된 설명문에서 한 장 이내로 요약하려다보니 깊게 들어간 내용까지는 정리를 못하기도 했고,
아래 부분의 설명문은 설명된 코드와 동작을 이해하지 못하여서 스택의 기본적은 흐름과 원리만 정리 할 수 있었습니다.
시스템 해킹을 계속 보면 볼수록 어셈블리어 공부에 대한 필요성을 강하게 느낄 수 있었습니다, 아직까지 어셈블리어에 대한 이해도가 정확하게 적립되지 않아서 정리가
좀 많이 허술하게 된 것 같아 부끄럽지만 다음에도 이와 비슷한 과제가 나온다면 정말 중요한 내용만 요악할 수 있는 실력까지 되어 있었으면 좋겠습니다.
